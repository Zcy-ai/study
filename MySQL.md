### 索引
索引是数据的目录
* 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引
* 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）
* 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引
* 按「字段个数」分类：单列索引、联合索引

InnoDB是MYSQL的默认存储引擎，B+Tree索引类型也是MySQL存储引擎采用最多的索引类型

如果有主键，默认会使用主键作为聚簇索引的索引键（key）
如果没有主键，就选择第一个不包含NULL值的唯一列作为聚簇索引的索引键（key）
在上面两个都没有的情况下，InnoDB将自动生成一个隐式自增id列作为聚簇索引的索引键
其它索引都属于辅助索引。创建的主键索引和二级索引默认使用的是B+Tree索引

B+Tree是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。
每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表

B+Tree相比于B树和二叉树来说，最大的优势在于查询效率很高，因为即使数据量很大的情况，查询一个数据的磁盘I/O依然维持在3-4次

主键索引的B+Tree和二级索引的B+Tree：
* 主键索引的B+Tree的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+Tree的叶子节点里
* 二级索引的B+Tree的叶子节点存放的是主键值，而不是实际数据

二级索引B+Tree的检索过程：
通过二级索引值找到对应的叶子节点，然后获取主键值，然后再通过主键索引的B+Tree查询到对应的叶子节点，获取数据。这个过程叫做「回表」，也就是说要查两个B+Tree才能查到数据

覆盖索引：二级索引的B+Tree就能查询到结果，比如通过二级索引查主键值

### 为什么MySQL采用B+Tree作为索引
考虑磁盘I/O操作次数，因为MySQL的数据存储在磁盘中
索引的数据结构应满足的要求：
* 能在尽可能少的磁盘的I/O操作中完成查询
* 要能高效地查询某一个记录，也要能高效地执行范围查找

##### 二叉搜索树
二叉搜索树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点
缺点：
当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)
树的高度就等于每次查询数据时I/O操作的次数

##### 自平衡二叉树
每个节点的左子树和右子树的高度差不能超过 1
缺点：
不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率

##### B树
B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树
每个节点最多有M-1个数据和最多有M个子节点

缺点：
* B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。
* 在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。
* 如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O问题，从而导致整体速度下降。

##### B+Tree
* 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
* 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
* 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）
* 非叶子节点中有多少个子节点，就有多少个索引；

1. 单点查询
B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少
2. 插入和删除效率
B+ 树由于存在冗余节点，不会发生复杂的树的变形，它的插入和删除效率更高
3. 范围查询
B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助

B+Tree vs Hash
Hash在做等值查询的时候效率高，复杂度为O（1）


按字段类型分类
主键索引：
一张表最多只有一个主键索引
唯一索引：
UNIQUE，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值
前缀索引：
前缀索引是指对字符类型字段的前几个字符建立的索引
```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
);
```


#### 事务隔离级别如何实现
##### 4个特性：
* 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成。，不会结束在某个中间环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态。原子性是通过回滚日志来保证的
* 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。一致性通过持久性、原子性、隔离性来保证
* 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。通过MVCC（多版本并发控制）或锁机制来保证
* 持久性：事务处理结束后，对数据的修改是永久的。通过redo log（重做日志来保证）

##### 脏读（拉完屎不擦）
如果一个事务读到了另一个事务未提交事务修改过的数据，就意味着发生了脏读现象。
🌰：
事务A和事务B是两个并行事务，事务B对数据库中的某条数据做出了更新，但还没有提交事务，此时，事务A读取了该修改过的数据，若事务B发生了回滚，那么事务A刚才得到的数据是过期数据，这种现象称为脏读

##### 不可重复读（读两次就不一样了）
在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了“不可重复读”现象
🌰：
事务A和事务B是两个并行的事务。事务A先读取了数据库中的一条数据，随后事务B更新了这条数据，那么当事务A再次读取该数据时，就会发生前后两次读到的数据是不一致的现象

##### 幻读（出现了幻觉）
在一个事务内多次查询某个符合查询条件的记录数量，如果出现两次查询到的记录数量不一样的情况，就意味着发生了幻读现象
🌰：
事务A先开始从数据库中查询满足某个条件的记录数量，随后事务B插入了一个符合条件的事务并提交了事务，那么如果事务A再次查询满足该条件的记录数量，就会发现前后两次读到的记录数量不一样，仿佛出现了幻觉一般

##### 事务的隔离级别
* 脏读：读到其他事务未提交的数据
* 不可重复读：前后读取的数据不一致
* 幻读：前后读取记录的数量不一致

##### 四种事务的隔离级别
* 读未提交： 指一个事务还没提交时，它做的变更就能被其他事务看到（仍然可能发生脏读、不可重复读和幻读）
* 读提交：指一个事务提交之后，它做的变更才能被其他事务看到，在每个语句执行之前都会重新生成一个Read View（仍然可能发生不可重复读和幻读）
* 可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别，启动事务时生成一个Read View（仍然可能发生幻读）
* 串行化： 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行（三种现象都不会发生）

按隔离水平高低排序：串行化>可重复读>读提交>读未提交

##### Read View在MVCC如何工作
Read View 有四个重要的字段：

* m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务
* min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。
* max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；
* creator_trx_id ：指的是创建该 Read View 的事务的事务 id。

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：
* trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
* roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
* 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
* 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
* 如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
    ** 如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
    ** 如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。

##### 可重复读是如何工作的

##### 读提交是如何工作的
区别主要在于min_trx_id,读提交由于每次语句执行前创建read view，在别人的修改事务提交之后，读提交的事务的min_trx_id也随之更新(变大)，可以读取min_trx_id之前的记录值

###### 为什么可重复读隔离级别仍然会发生幻读现象

MySQL InnoDB引擎的默认隔离级别虽然是可重复读，但是它很大程度上避免了幻读现象

解决方案：
* 针对快照读（普通SELECT语句），是通过MVCC方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入一条数据，是查询不出来这条数据的，所以就很好的避免了幻读问题
* 针对（SELECT...FOR UPDATE等语句），是通过next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行select...for update语句的时候，会加上next-key lock，如果有其他事务在next-key lock锁范围内插入一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好避免了幻读问题

###### 快照读如何避免幻读
可重复读隔离级是由MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行begin语句后），在执行第一个查询语句后，会创建一个Read View，后续的查询语句利用这个Read View，通过这个Read View就可以在undo log版本链找到事务开始时的数据，所以在事务过程中每次查询的数据都是一样的

###### 当前读如何避免幻读
MySQL里除了普通查询是快照读，其他都是当前读，比如update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作

Innodb引擎为了解决可重复读隔离级别使用当前读而造成的幻读问题，就引出了间隙锁，假设表中有一个id范围为（3，5）的间隙锁，就无法插入id=4这条记录了，这样就有效防止幻读现象的发生

🌰：
事务A执行了下面的sql语句
```sql
begin;
SELECT name FROM t_stu
WHERE id > 2
FOR UPDATE;
```
事务A执行了这条SQL语句之后，就在对表中的记录加上id范围为(2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）
然后，事务B在执行插入语句的时候，判断到插入的位置被事务A家了next-key lock，于是事务B会生成一个插入意向锁，同时进入等待状态，直到事务A执行commit

###### 仍然发生幻读的场景
🌰：
事务A
```sql
begin;
select * from t_stu where id = 5;
```

事务B
```sql
begin;
insert into t_stu values(5, 'Messi', 35);
commit;
```

事务A
```sql
update t_stu set name = '小林coding' where id = 5;
select * from t_stu where id = 5;
```

在可重复读隔离级别下，事务A第一次执行普通的select语句时生成了一个 ReadView，之后事务B向表中新插入了一条id=5的记录并提交。接着，事务 A对id=5这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务A的事务id，之后事务A再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。

trx_id：每个事务在执行时都会被分配一个唯一的trx_id。这个trx_id可以用于在系统日志中追踪事务的执行情况，也可以用于实现MVCC等并发控制机制。需要注意的是，trx_id是在事务开始时分配的，因此如果一个事务中途崩溃了，其trx_id可能会被重用。这种情况下，事务的后续操作可能会被误认为是先前事务的操作。因此，在使用trx_id进行并发控制时，需要注意避免这种情况的发生。

除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。
🌰：
T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。
T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。
要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。

