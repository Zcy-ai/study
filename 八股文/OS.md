
#### Kernel
* 进程调度
* 内存管理
* 硬件通信
* 系统调用

内存分为两个区域：内核空间（内核态）、用户空间（用户态）

##### Linux
###### MultiTask
* 对于单核 CPU 时，可以让每个任务执行一小段时间，时间到就切换另外一个任务，从宏观角度看，一段时间内执行了多个任务，这被称为并发。
* 对于多核 CPU 时，多个任务可以同时被不同核心的 CPU 同时执行，这被称为并行。

###### SMP（对称多处理）
每个CPU的地位是相等的，对资源的使用权限也是相同的，多个CPU共享同一个内存，每个CPU都可以访问完整的内存和硬件资源。决定了每个程序都可以被分配到任意一个CPU上被执行

###### ELF（可执行文件链接格式）
Linux操作系统中可执行文件的存储格式。ELF把文件分成了一个个分段，每一个段都有自己的作用，

###### Monolithic Kernel（宏内核）
Linux内核架构就是宏内核，意味着Linux的内核就是一个完整的可执行程序，且拥有最高的权限
宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。

###### 微内核
微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。
微内核内核功能少，可移植性高，相比宏内核有一点不好的地方在于，由于驱动程序不在内核中，而且驱动程序一般会频繁调用底层能力的，于是驱动和硬件设备交互就需要频繁切换到内核态，这样会带来性能损耗。

Linux 的内核设计是采用了宏内核，Window 的内核设计则是采用了混合内核，鸿蒙采用微内核。

## 进程管理
多个程序、交替执行
并发、并行
进程的状态：运行状态（该时刻进程占用CPU）、就绪状态（由于其他进程处于运行状态而暂时停止运行）、阻塞状态（该进程正在等待某一事件发生而暂时停止运行，即时给它CPU控制权也无法运行、创建状态、结束状态

在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存换出到磁盘，等需要再次运行的时候，再从磁盘换入到物理内存。
挂起状态：进程没有占用实际的物理内存空间

PCB：进程控制块，进程存在的唯一标识，意味着一个进程的存在必然会有一个PCB，进程消息，PCB随之消失
PCB包含信息：进程描述信息（进程标识符、用户标识符）、进程控制和管理信息（进程当前状态、优先级）、资源分配清单、CPU相关信息（CPU中各个寄存器的值，当进程被切换时，CPU的状态信息都会被保存在相应的PCB中，以便进程重新执行时，能从断点处继续执行）

PCB通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列

当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作

#### 进程的上下文切换
一个进程切换到另一个进程的运行，称为进程的上下文切换
CPU寄存器和程序计数器（存储CPU正在执行的指令位置），它们时CPU在运行任何任务前，所必须依赖的环境，这些环境就叫做CPU上下文。
进程的上下文切换（只发生在内核态）。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。
发生进程上下文切换的场景：
* 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
* 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
* 进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
* 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
* 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

## 线程
线程之间可以并发运行且共享相同的地址空间，是进程当中的一条执行流程
同一个进程内的多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的
当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃

#### 线程的上下文切换
线程是调度的基本单位，而进程则是资源拥有的基本单位
当进程只有一个线程时，可以认为进程就等于线程
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不用修改的

当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；

#### 线程的实现
用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理
内核线程：在内核中实现的线程，是由内核管理的线程；
轻量级线程：在内核中来支持用户线程

用户线程是基于用户态的线程管理库来实现的，那么线程控制块（TCB）也是在库里实现的
用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等

轻量级进程时内核支持的用户线程，一个进程可有一个或多个LWP，每个LWP是跟内核线程一对一映射的，也就是LWP都是由一个内核线程支持，而且LWP是由内核管理并像普通进程一样被调度

#### 调度
* 非抢占式调度算法挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
* 抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。

调度原则
* 原则一：如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。
* 原则二：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。
* 原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。
* 原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则。
* 原则五：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。

## 进程通信
#### 管道
mkfifo 管道名
写入管道、读取管道
本质：内核里的一串缓存。从管道的一段写入数据，实际是缓存在内核中，另一端读取，也就是从内核中读取这段数据
对于匿名管道，它的通信范围是存在父子关系的进程
对于命名管道，它可以在不相关的进程间也能相互通信
传输的是无格式的字节流数据
遵循FIFO

#### 消息队列
消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型。
不足：通信不及时，附件也有大小限制、消息队列不适合比较大数据的传输、存在用户态与内核态之间的数据拷贝开销

#### 共享内存
共享内存不会有用户态与内核态之间的消息拷贝过程
共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中

#### 信号量
为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问
信号量其实是一个整型的计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据
P操作：这个操作会把信号量减去1，减完后如果信号量<0，则表明资源已经被占用，进程需阻塞等待；如果>=0，则表明还有资源可用，进程可以继续执行
V操作：这个操作会把信号量加上1，相加后如果信号量<= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

初始化为1代表互斥信号量，初始化为0代表同步信号量

#### 信号
对于异常情况下的工作模式，就需要用信号的方式来通知进程
信号是进程间通信机制中唯一的异步通信机制：1. 执行默认操作 2. 捕捉信号 3. 忽略信号

#### Socket
管道、消息队列、共享内存、信号量和信号都是在同一主机上进行进程通信，要想跨网络与不同主机上的进程之间通信，就需要Socket通信

基于TCP协议
基于UDP协议
本地进程间的通信

## 多线程冲突
#### 互斥
data race：由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为临界区，它是访问共享资源的代码片段，一定不能给多线程同时执行。我们希望这段代码是互斥的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区。就是在这段代码执行过程中，最多只能出现一个线程。
#### 同步
线程1是负责读取数据的，而线程2是负责处理数据的，这两个线程是相互合作、相互依赖的。线程2在没有收到线程1的唤醒通知时，就会一直阻塞等待，当线程1读完数据需要把数据传给线程2时，线程1会唤醒线程2，并把数据交给线程2处理。
所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。
同步就好比：操作A应在操作B之前执行，操作C必须在操作A和操作B都完成之后才能执行
#### 互斥与同步的实现和使用
锁和信号量（P、V）
* P 操作：将 sem 减 1，相减后，如果 sem < 0，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；
* V 操作：将 sem 加 1，相加后，如果 sem <= 0，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；

生产者-消费者问题
哲学家就餐问题
读者写者问题

#### 如何避免死锁
死锁发生条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件
互斥条件：多个线程不能同时使用同一个资源
持有并等待条件：线程A在等待资源的同时并不会释放自己已经持有的资源
不可剥夺条件：在自己使用完之前不能被其他线程获取
环路等待：两个线程获取资源的顺序构成来环形链

## 各种类型的锁

#### 互斥锁和自旋锁
互斥锁加锁失败后，线程会释放CPU
自旋锁加锁失败后，线程会忙等待，直到它拿到锁
互斥锁加锁失败时，会从用户态进入到内核态

如果确定被锁住的代码执行时间很短，就不应该使用互斥锁，而使用自旋锁
自旋锁通过CPU提供的CAS函数，在用户态完成加锁和解锁操作，不会主动产生线程的上下文切换
需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU

#### 读写锁
读写锁适用于能明确区分读操作和写操作的场景
读写锁的工作原理是：
* 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
* 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

读优先锁、写优先锁、公平读写锁
公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。

#### 乐观锁和悲观锁
互斥锁、自旋锁、读写锁，都是属于悲观锁
悲观锁：多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以共享资源之前，先要上锁
乐观锁：先修改完共享资源，再验证这段时间内没有发生冲突，如果没有其他线程修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作

乐观锁一般在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁